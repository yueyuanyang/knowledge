## 设计模式 —— 构建者(Builder)

### 设计模式六大原则

#### 一.单一职责原则

> 单一职责原则(Single Responsibility Principle, SRP)：一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。

单一职责原则告诉我们：一个类不能太"累"在软件系统中，一个类（大到模块，小到方法）承担的职责越多，它被复用的可能性就越小，而且一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作，因此要将这些职责进行分离，将不同的职责封装在不同的类中，即将不同的变化原因封装在不同的类中，如果多个职责总是同时发生改变则可将它们封装在同一类中。

单一职责原则是实现`高内聚、低耦合`的指导方针，它是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，而发现类的多重职责需要设计人员具有较强的分析设计能力和相关实践经验。

#### 二.开闭原则

> 开闭原则(Open-Closed Principle, OCP)：一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。

 在开闭原则的定义中，软件实体可以指一个软件模块、一个由多个类组成的局部结构或一个独立的类。任何软件都需要面临一个很重要的问题，即它们的需求会随时间的推移而发生变化。当软件系统需要面对新的需求时，我们应该尽量保证系统的设计框架是稳定的。如果一个软件设计符合开闭原则，那么可以非常方便地对系统进行扩展，而且在扩展时无须修改现有代码，使得软件系统在拥有适应性和灵活性的同时具备较好的稳定性和延续性。随着软件规模越来越大，软件寿命越来越长，软件维护成本越来越高，设计满足开闭原则的软件系统也变得越来越重要。为了满足开闭原则，需要对系统进行抽象化设计，抽象化是开闭原则的关键。在Java、C#等编程语言中，可以为系统定义一个相对稳定的抽象层，而将不同的实现行为移至具体的实现层中完成。在很多面向对象编程语言中都提供了接口、抽象类等机制，可以通过它们定义系统的抽象层，再通过具体类来进行扩展。如果需要修改系统的行为，无须对抽象层进行任何改动，只需要增加新的具体类来实现新的业务功能即可，实现在不修改已有代码的基础上扩展系统的功能，达到开闭原则的要求
     


**我们先看设计模式的分类：**

| 范围 | 创建型 | 结构型 | 行为型 |
| - | - | - |  - |
| 类 | Factory Method（工厂方法）| Adapter(类)(适配器) | Interpreter（解释器）<br>Template Method（模版方法）
| 对象 | Abstract Factory（抽象工厂）<br> Builder（建造者）<br>Prototype（原型）<br>Singleton（单例） | Adapter(对象)（适配器）<br>Bridge（桥接）<br>Composite（组合）<br>Decorator（装饰者）<br>Facade（外观）<br>Flyweight（享元）<br>Proxy（代理） | Chain of Responsibility（职责链）<br>Command（命令）<br>Iterator（迭代器）<br>Mediator（中介者）<br>Memento（备忘录）<br>Observer（观察者）<br>State（状体）<br>Strategy（策略）<br>Visitor（访问者）

**再细点分类**

| 范围 | 创建型 | 结构型 | 行为型 |
| - | - | - |  - |
| 对象创建 | Singleton（单例）<br>Prototype（原型）<br>Factory Method（工厂方法）<br>Abstract Factory（抽象工厂）<br>Builder（建造者）| | 
| 接口适配 | | Adapter（适配器）<br>Bridge（桥接）<br>Façade（外观） | Interpreter（解释器）<br>Template Method（模版方法）
| 对象去耦 | | | Mediator（中介者）<br>Observer（观察者）
| 抽象集合 | | Composite（组合） | IIterator（迭代器）
| 行为扩展 | | Decorator（装饰） | Visitor（访问者）<br>Chain of Responsibility（职责链）
| 算法封装 | |  | Template Method（模板方法）<br>Strategy（策略）<br>Command
| 性能与对象访问 | | Flyweight（享元）<br>Proxy（代理） | 
| 对象状态 ||  |Memento（备忘录）<br> State（状态）
| 其他 | || Interpreter（解释器）

