## 设计模式 —— 构建者(Builder)


**我们先看设计模式的分类：**

| 范围 | 创建型 | 结构型 | 行为型 |
| - | - | - |  - |
| 类 | Factory Method（工厂方法）| Adapter(类)(适配器) | Interpreter（解释器）<br>Template Method（模版方法）
| 对象 | Abstract Factory（抽象工厂）<br> Builder（建造者）<br>Prototype（原型）<br>Singleton（单例） | Adapter(对象)（适配器）<br>Bridge（桥接）<br>Composite（组合）<br>Decorator（装饰者）<br>Facade（外观）<br>Flyweight（享元）<br>Proxy（代理） | Chain of Responsibility（职责链）<br>Command（命令）<br>Iterator（迭代器）<br>Mediator（中介者）<br>Memento（备忘录）<br>Observer（观察者）<br>State（状体）<br>Strategy（策略）<br>Visitor（访问者）

**再细点分类**

| 范围 | 创建型 | 结构型 | 行为型 |
| - | - | - |  - |
| 对象创建 | Singleton（单例）<br>Prototype（原型）<br>Factory Method（工厂方法）<br>Abstract Factory（抽象工厂）<br>Builder（建造者）| | 
| 接口适配 | | Adapter（适配器）<br>Bridge（桥接）<br>Façade（外观） | Interpreter（解释器）<br>Template Method（模版方法）
| 对象去耦 | | | Mediator（中介者）<br>Observer（观察者）
| 抽象集合 | | Composite（组合） | IIterator（迭代器）
| 行为扩展 | | Decorator（装饰） | Visitor（访问者）<br>Chain of Responsibility（职责链）
| 算法封装 | |  | Template Method（模板方法）<br>Strategy（策略）<br>Command
| 性能与对象访问 | | Flyweight（享元）<br>Proxy（代理） | 
| 对象状态 ||  |Memento（备忘录）<br> State（状态）
| 其他 | || Interpreter（解释器）




### 设计模式六大原则

#### 一.单一职责原则

> 单一职责原则(Single Responsibility Principle, SRP)：一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。

单一职责原则告诉我们：一个类不能太"累"在软件系统中，一个类（大到模块，小到方法）承担的职责越多，它被复用的可能性就越小，而且一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作，因此要将这些职责进行分离，将不同的职责封装在不同的类中，即将不同的变化原因封装在不同的类中，如果多个职责总是同时发生改变则可将它们封装在同一类中。

单一职责原则是实现`高内聚、低耦合`的指导方针，它是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，而发现类的多重职责需要设计人员具有较强的分析设计能力和相关实践经验。

#### 二.开闭原则

> 开闭原则(Open-Closed Principle, OCP)：一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。

 在开闭原则的定义中，软件实体可以指一个软件模块、一个由多个类组成的局部结构或一个独立的类。
 
 任何软件都需要面临一个很重要的问题，即它们的需求会随时间的推移而发生变化。当软件系统需要面对新的需求时，我们应该尽量保证系统的设计框架是稳定的。如果一个软件设计符合开闭原则，那么可以非常方便地对系统进行扩展，而且在扩展时无须修改现有代码，使得软件系统在拥有适应性和灵活性的同时具备较好的稳定性和延续性。随着软件规模越来越大，软件寿命越来越长，软件维护成本越来越高，设计满足开闭原则的软件系统也变得越来越重要。
 
 为了满足开闭原则，需要对系统进行抽象化设计，抽象化是开闭原则的关键。在Java、C#等编程语言中，可以为系统定义一个相对稳定的抽象层，而将不同的实现行为移至具体的实现层中完成。在很多面向对象编程语言中都提供了接口、抽象类等机制，可以通过它们定义系统的抽象层，再通过具体类来进行扩展。如果需要修改系统的行为，无须对抽象层进行任何改动，只需要增加新的具体类来实现新的业务功能即可，实现在不修改已有代码的基础上扩展系统的功能，达到开闭原则的要求
     
#### 三.里氏替换原则

>里氏代换原则(Liskov Substitution Principle, LSP)：所有引用基类（父类）的地方必须能透明地使用其子类的对象。

里氏代换原则告诉我们，在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。例如：我喜欢动物，那我一定喜欢狗，因为狗是动物的子类；但是我喜欢狗，不能据此断定我喜欢动物，因为我并不喜欢老鼠，虽然它也是动物。

例如有两个类，一个类为BaseClass，另一个是SubClass类，并且SubClass类是BaseClass类的子类，那么一个方法如果可以接受一个BaseClass类型的基类对象base的话，如：method1(base)，那么它必然可以接受一个BaseClass类型的子类对象sub，method1(sub)能够正常运行。反过来的代换不成立，如一个方法method2接受BaseClass类型的子类对象sub为参数：method2(sub)，那么一般而言不可以有method2(base)，除非是重载方法。

里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。

#### 四.依赖倒置原则
> 依赖倒转原则(Dependency Inversion  Principle, DIP)：抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。

依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。为了确保该原则的应用，一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增加的新方法。

在引入抽象层后，系统将具有很好的灵活性，在程序中尽量使用抽象层进行编程，而将具体类写在配置文件中，这样一来，如果系统行为发生变化，只需要对抽象层进行扩展，并修改配置文件，而无须修改原有系统的源代码，在不修改的情况下来扩展系统的功能，满足开闭原则的要求。

在实现依赖倒转原则时，我们需要针对抽象层编程，而将具体类的对象通过依赖注入(DependencyInjection, DI)的方式注入到其他对象中，依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。常用的注入方式有三种，分别是：构造注入，设值注入（Setter注入）和接口注入。构造注入是指通过构造函数来传入具体类的对象，设值注入是指通过Setter方法来传入具体类的对象，而接口注入是指通过在接口中声明的业务方法来传入具体类的对象。这些方法在定义时使用的是抽象类型，在运行时再传入具体类型的对象，由子类对象来覆盖父类对象。

#### 五.接口隔离原则

> 接口隔离原则(Interface  Segregation Principle, ISP)：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。

  根据接口隔离原则，当一个接口太大时，我们需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。每一个接口应该承担一种相对独立的角色，不干不该干的事，该干的事都要干。这里的“接口”往往有两种不同的含义：一种是指一个类型所具有的方法特征的集合，仅仅是一种逻辑上的抽象；另外一种是指某种语言具体的“接口”定义，有严格的定义和结构，比如Java语言中的interface。对于这两种不同的含义，ISP的表达方式以及含义都有所不同：

(1) 当把“接口”理解成一个类型所提供的所有方法特征的集合的时候，这就是一种逻辑上的概念，接口的划分将直接带来类型的划分。可以把接口理解成角色，一个接口只能代表一个角色，每个角色都有它特定的一个接口，此时，这个原则可以叫做“角色隔离原则”。

(2) 如果把“接口”理解成狭义的特定语言的接口，那么ISP表达的意思是指接口仅仅提供客户端需要的行为，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口。在面向对象编程语言中，实现一个接口就需要实现该接口中定义的所有方法，因此大的总接口使用起来不一定很方便，为了使接口的职责单一，需要将大接口中的方法根据其职责不同分别放在不同的小接口中，以确保每个接口使用起来都较为方便，并都承担某一单一角色。接口应该尽量细化，同时接口中的方法应该尽量少，每个接口中只包含一个客户端（如子模块或业务逻辑类）所需的方法即可，这种机制也称为“定制服务”，即为不同的客户端提供宽窄不同的接口。

#### 六.迪米特法则
> 迪米特法则(Law of  Demeter, LoD)：一个软件实体应当尽可能少地与其他实体发生相互作用。

如果一个系统符合迪米特法则，那么当其中某一个模块发生修改时，就会尽量少地影响其他模块，扩展会相对容易，这是对软件实体之间通信的限制，迪米特法则要求限制软件实体之间通信的宽度和深度。迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系。

迪米特法则还有几种定义形式，包括：不要和“陌生人”说话、只与你的直接朋友通信等，在迪米特法则中，对于一个对象，其朋友包括以下几类：

(1) 当前对象本身(this)；
(2) 以参数形式传入到当前对象方法中的对象；
(3) 当前对象的成员对象；
(4) 如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友；
(5) 当前对象所创建的对象。

任何一个对象，如果满足上面的条件之一，就是当前对象的“朋友”，否则就是“陌生人”。在应用迪米特法则时，一个对象只能与直接朋友发生交互，不要与“陌生人”发生直接交互，这样做可以降低系统的耦合度，一个对象的改变不会给太多其他对象带来影响。

迪米特法则要求我们在设计系统时，应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用。简言之，就是通过引入一个合理的第三者来降低现有对象之间的耦合度。

在将迪米特法则运用到系统设计中时，要注意下面的几点：在类的划分上，应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及；在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限；在类的设计上，只要有可能，一个类型应当设计成不变类；在对其他类的引用上，一个对象对其他对象的引用应当降到最低。


### 开发者必须掌握的几种软件的设计模式

设计模式的好处有很多，设计模式是一套被反复使用，经过分类编目的代码设计经验的总结，使用设计模式是为了成功的设计和体系结构
服用相似问题的相同解决方案。保证了代码的可靠性，是代码的编制真正的工程化，能够适应需求的变化。

里氏替换原则，如果一个软件实体使用一个父类的话，那么一定适用于子类。定义就是子类必须能够替换它的父类。
迪米特法则：他强调的是类之间的松耦合，耦合度越低越有利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成影响。

- 1.简单工厂模式：将业务逻辑部分和界面逻辑部分分离开来，降低了业务逻辑部分和界面逻辑部分的耦合度，符合面向对象的迪米特法则。
- 2.工厂模式：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到了子类。
- 3.抽象工厂模式;提供一个创建一系列相关或者相互依赖的对象的接口，而无需指定他们具体的类。
- 4.职责链设计模式（chain of responsibility）：使多个对象都有处理请求的机会，从而避免了请求的发送者和接受者之间的耦合关系，将所有的处理对象连成一条链，并沿着这条链传递请求，直到有一个对象能够处理它为止。
- 5.单身设计模式：（singleton）；保证一个类仅仅有一个实例，并提供一个访问他的全局访问点，通常我们可以让一个全局变量使得一个对象被访问，但他不能防止你实例化多个对象，一个最好的方法就是，让类自身保护它唯一的实例，这个类可以保证它没有其他的实例被创建，并且它可以提供一个访问该实例的方法。
- 6.适配器设计模式：（Adapter）：讲一个；类的接口转化为客户希望的另一个接口，Adapter模式使得原来接口不兼容而不能一起工作的那些类可以一起工作了。
- 7.装饰设计模式：（Decorator）：动态地给一个对象添加一些额外的职责。即增加功能来说，装饰模式比生成子类更为灵活。
- 8.代理模式：（Proxy）：为其他对象提供一种代理以达到控制这个对象的访问。
- 9.观察者设计模式：又称发布--订阅模式，定义了一个一对多的依赖关系，让多个观察者对象同时监听某一个主题对象，这个主题对象在状态发生变化时，会通知所有的观察者对象，使他们能够自动的进行更新。
- 10.状态设计模式：当一个对象的内在状态发生改变时允许改变其行为，这个对象看起来像是改变了类，状态模式主要解决的是当控制一个对象转换的条件表达式过于复杂的情况。把状态的判断逻辑转移到表示不同状态的的一系列的类中，可以把复杂的逻辑简化。好处是将特定状态的相关行为局部化，且将不同状态的行为分割开来。
- 11.命令设计模式：命令设计模式的作用是将一个请求封装成一个对象，从而使我们可以用不同的请求对象进行参数化，对请求排队或者是请求记录日志，以及支持科撤销的操作，命令模式将调用操作的请求对象与知道如何实现改操作的接受对象解耦，
- 12.模板设计模式：定义一个算法骨架，而且将一些步骤延迟到子类中，模板方法使得子类可以不改变一个算法的结构即可重新定义算法的特定步骤。
- 13桥接设计模式;将抽象部分与它的现实部分想分离，使它们可以独立的变化，桥接设计模式可以避免“类爆炸”的情况
- 14.策略设计模式：定义了一个算法家庭，分别把他们都封装起来，让他们之间可以相互替换，这些算法的替换变化不会影响到使用算法的客户。
- 15组合设计模式;将对象组合成树的结构以表示“部分--与整体”的的层次结构，组合模式使得单个用户对单个对象的使用具有一致性。
- 16.原型设计模式：用原型的实例指定创建类的总类，并且通过拷贝这个原型来创建的新的对象。




