## 基于TextRank的关键词、短语、摘要提取

**关于自动文摘**

利用计算机将大量的文本进行处理，产生简洁、精炼内容的过程就是文本摘要，人们可通过阅读摘要来把握文本主要内容，这不仅大大节省时间，更提高阅读效率。但人工摘要耗时又耗力，已不能满足日益增长的信息需求，因此借助计算机进行文本处理的自动文摘应运而生。近年来，自动文摘、信息检索、信息过滤、机器识别、等研究已成为了人们关注的热点。

**自动文摘**（Automatic Summarization）的方法主要有两种：**Extraction**和**Abstraction**。

其中Extraction是抽取式自动文摘方法，通过提取文档中已存在的关键词，句子形成摘要；Abstraction是生成式自动文摘方法，通过建立抽象的语意表示，使用自然语言生成技术，形成摘要。由于生成式自动摘要方法需要复杂的自然语言理解和生成技术支持，应用领域受限。所以本人学习的也是抽取式的自动文摘方法。

目前主要方法有：

- 基于统计：统计词频，位置等信息，计算句子权值，再简选取权值高的句子作为文摘，特点：简单易用，但对词句的使用大多仅停留在表面信息。
- 基于图模型：构建拓扑结构图，对词句进行排序。例如，TextRank/LexRank
- 基于潜在语义：使用主题模型，挖掘词句隐藏信息。例如，采用LDA，HMM
- 基于整数规划：将文摘问题转为整数线性规划，求全局最优解。

### TextRank算法

TextRank 算法是一种用于文本的基于图的排序算法。其基本思想来源于谷歌的 PageRank算法, 通过把文本分割成若干组成单元(单词、句子)并建立图模型, 利用投票机制对文本中的重要成分进行排序, 仅利用单篇文档本身的信息即可实现关键词提取、文摘。和 LDA、HMM 等模型不同, TextRank不需要事先对多篇文档进行学习训练, 因其简洁有效而得到广泛应用。

**PageRank**

PageRank最开始用来计算网页的重要性。整个www可以看作一张有向图图，节点是网页。如果网页A存在到网页B的链接，那么有一条从网页A指向网页B的有向边。

构造完图后，使用下面的公式：

![p9](https://github.com/yueyuanyang/knowledge/blob/master/ML/img/p9.png)

S(Vi)是网页i的中重要性（PR值）。d是阻尼系数，一般设置为0.85。In(Vi)是存在指向网页i的链接的网页集合。Out(Vj)是网页j中的链接存在的链接指向的网页的集合。|Out(Vj)|是集合中元素的个数。

PageRank需要使用上面的公式多次迭代才能得到结果。初始时，可以设置每个网页的重要性为1。上面公式等号左边计算的结果是迭代后网页i的PR值，等号右边用到的PR值全是迭代前的。

**正规的TextRank公式**

正规的TextRank公式在PageRank的公式的基础上，引入了边的权值的概念，代表两个句子的相似度。

![p11](https://github.com/yueyuanyang/knowledge/blob/master/ML/img/p11.png)

但是很明显我只想计算关键字，如果把一个单词视为一个句子的话，那么所有句子（单词）构成的边的权重都是0（没有交集，没有相似性），所以分子分母的权值w约掉了，算法退化为PageRank。所以说，这里称关键字提取算法为PageRank也不为过。

**TextRank提取关键字**

关键词抽取的任务就是从一段给定的文本中自动抽取出若干有意义的词语或词组。将原文本拆分为句子，在每个句子中过滤掉停用词（可选），并只保留指定词性的单词（可选）。由此可以得到句子的集合和单词的集合。TextRank算法是利用局部词汇之间关系（共现窗口）对后续关键词进行排序，直接从文本本身抽取。其主要步骤如下：

1、把给定的文本T按照完整句子进行分割，即:

![p10](https://github.com/yueyuanyang/knowledge/blob/master/ML/img/p10.png)

### TextRank提取关键短语

参照“使用TextRank提取关键词”提取出若干关键词。若原文本中存在若干个关键词相邻的情况，那么这些关键词可以构成一个关键短语。

例如，在一篇介绍“支持向量机”的文章中，可以找到三个关键词 支持、向量、机，通过关键短语提取，可以得到支持向量机.

[TextRank的scala实现](https://github.com/STHSF/TextRank)

如果不明白以实际的案例来讲解：

先看看测试数据：

```
程序员(英文Programmer)是从事程序开发、维护的专业人员。一般将程序员分为程序设计人员和程序编码人员，但两者的界限并不非常清楚，特别是在中国。软件从业人员分为初级程序员、高级程序员、系统分析员和项目经理四大类
```
我取出了百度百科关于“程序员”的定义作为测试用例，很明显，这段定义的关键字应当是“程序员”并且“程序员”的得分应当最高。

首先对这句话分词，这里可以借助各种分词项目，比如HanLP 或 jieba分词，得出分词结果：
```
[程序员/n, (, 英文/nz, programmer/en, ), 是/v, 从事/v, 程序/n, 开发/v, 、/w, 
维护/v, 的/uj, 专业/n, 人员/n, 。/w, 一般/a, 将/d, 程序员/n, 分为/v, 程序/n, 
设计/vn, 人员/n, 和/c, 程序/n, 编码/n, 人员/n, ，/w, 但/c, 两者/r, 的/uj, 
界限/n, 并/c, 不/d, 非常/d, 清楚/a, ，/w, 特别/d, 是/v, 在/p, 中国/ns, 
。/w, 软件/n, 从业/b, 人员/n, 分为/v, 初级/b, 程序员/n, 、/w, 高级/a, 
程序员/n, 、/w, 系统/n, 分析员/n, 和/c, 项目/n, 经理/n, 四/m, 大/a, 
类/q, 。/w]
```

然后去掉里面的停用词，这里我去掉了标点符号、常用词、以及“名词、动词、形容词、副词之外的词”。得出实际有用的词语：
```
[程序员, 英文, 程序, 开发, 维护, 专业, 人员, 程序员, 
分为, 程序, 设计, 人员, 程序, 编码, 人员, 界限, 特别, 
中国, 软件, 人员, 分为, 程序员, 高级, 程序员, 系统, 
分析员, 项目, 经理]

```
之后建立两个大小为5的窗口，每个单词将票投给它身前身后距离5以内的单词：

```
{开发=[专业, 程序员, 维护, 英文, 程序, 人员],

 软件=[程序员, 分为, 界限, 高级, 中国, 特别, 人员],

 程序员=[开发, 软件, 分析员, 维护, 系统, 项目, 经理, 分为, 
 英文, 程序, 专业, 设计, 高级, 人员, 中国],

 分析员=[程序员, 系统, 项目, 经理, 高级],

 维护=[专业, 开发, 程序员, 分为, 英文, 程序, 人员],

 系统=[程序员, 分析员, 项目, 经理, 分为, 高级],

 项目=[程序员, 分析员, 系统, 经理, 高级],

 经理=[程序员, 分析员, 系统, 项目],

 分为=[专业, 软件, 设计, 程序员, 维护, 系统, 高级, 程序, 中国, 特别, 人员],

 英文=[专业, 开发, 程序员, 维护, 程序],

 程序=[专业, 开发, 设计, 程序员, 编码, 维护, 界限, 分为, 英文, 特别, 人员],

 特别=[软件, 编码, 分为, 界限, 程序, 中国, 人员],

 专业=[开发, 程序员, 维护, 分为, 英文, 程序, 人员],

 设计=[程序员, 编码, 分为, 程序, 人员],

 编码=[设计, 界限, 程序, 中国, 特别, 人员],

 界限=[软件, 编码, 程序, 中国, 特别, 人员],

 高级=[程序员, 软件, 分析员, 系统, 项目, 分为, 人员],

 中国=[程序员, 软件, 编码, 分为, 界限, 特别, 人员],

 人员=[开发, 程序员, 软件, 维护, 分为, 程序, 特别, 专业, 设计, 编码, 界限, 高级, 中国]}

```

然后开始迭代投票：

```
  for (int i = 0; i < max_iter; ++i)
  {
      Map<String, Float> m = new HashMap<String, Float>();
      float max_diff = 0;
      for (Map.Entry<String, Set<String>> entry : words.entrySet())
      {
          String key = entry.getKey();
          Set<String> value = entry.getValue();
          m.put(key, 1 - d);
          for (String other : value)
          {
              int size = words.get(other).size();
              if (key.equals(other) || size == 0) continue;
              m.put(key, m.get(key) + d / size * (score.get(other) == null ? 0 : score.get(other)));
          }
          max_diff = Math.max(max_diff, Math.abs(m.get(key) - (score.get(key) == null ? 0 : score.get(key))));
      }
      score = m;
      if (max_diff <= min_diff) break;
  }

```

排序后的投票结果：

```
[程序员=1.9249977,

人员=1.6290349,

分为=1.4027836,

程序=1.4025855,

高级=0.9747374,

软件=0.93525416,

中国=0.93414587,

特别=0.93352026,

维护=0.9321688,

专业=0.9321688,

系统=0.885048,

编码=0.82671607,

界限=0.82206935,

开发=0.82074183,

分析员=0.77101076,

项目=0.77101076,

英文=0.7098714,

设计=0.6992446,

经理=0.64640945]

```

程序员果然荣登榜首，并且分数也有区分度，嗯，勉勉强强。

### 总结

**程序步骤**：

1、**文章分词**： 对每一篇文章进行分词，分词系统主要由坤雁分词系统、ansj分词，结巴分词等。

2、**分词结果数据清洗**： 主要包括去停用词、去除符号字母数字等。

3、**构建候选关键词图**： 根据设定的词语选择窗口截取文本的分词结果，将每个词语作为候选关键词图的节点，截取的每一段文本中的词语作为相邻的边，以此构建候选关键词图。

4、**关键词提取**： 利用pagerank思想循环迭代候选关键词图， 每个节点的权重初始化化为1.0f，通过设定的迭代次数达到稳定后，对节点权重进行倒序排序，从而得到最重要的num个单词，作为候选关键词。

程序主要包含两大部分，第一部分为候选关键词图构件。第二部分为关键词提取。

开源项目地址: https://github.com/STHSF/TextRank










